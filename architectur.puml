
@startuml
title IKT300 Microkernel - Runtime Architecture

skinparam packageStyle rectangle
skinparam shadowing false

package "Microkernel Host (IKT300.Microkernel)" {
    [Program.cs\nEntry point] as Entry
    [KernelServer\nLifetime + background tasks] as Kernel
    [PluginRegistry\nConcurrentDictionary<PluginInstance>] as Registry
    [PluginProcessManager\nCreatePluginStartInfo + dotnet exec/run] as ProcessMgr
    [MessageRouter\nAcceptLoop + ProcessMessage + Broadcast] as Router
    [HeartbeatMonitor\n8s timeout + restart] as HBMonitor
    [CommandLoop\nConsole CLI (list/kill/start/help)] as CommandUI
    database "kernel-heartbeats.log" as HBLog
}

package "Shared Library (IKT300.Shared)" {
    [KernelConfig\n+ PluginConfig] as SharedConfig
    [Message Schema\nHeader + Metadata + Payload] as MessageSchema
    [Domain Events\nUserLoggedInEvent + DataProcessedEvent] as DomainEvents
}

package "Configuration" {
    artifact "kernelconfig.json\n(host, port, plugins)" as ConfigFile
}

package "IPC Layer" {
    [TcpListener\n127.0.0.1:9000] as Listener
    [NetworkStream\nper plugin connection] as Stream
    [System.Text.Json\nnewline framed messages] as JsonCodec
}

package "Plugins (net8.0)" {
    component EventSim as "[IKT300.Plugin.EventSimulator\nproducer]"
    component MetricLogger as "[IKT300.Plugin.MetricLogger\nconsumer]"
    database "metriclogger-metrics.log" as MetricsLog
}

Entry --> SharedConfig : LoadFromDefaultLocations()
ConfigFile --> SharedConfig : JSON source
Entry --> Kernel : new KernelServer(config)

Kernel --> Registry : Register PluginInstance
Kernel --> ProcessMgr : StartPluginProcess()
Kernel --> Router : Start AcceptLoop
Kernel --> HBMonitor : Start heartbeat task
Kernel --> CommandUI : Start console loop

ProcessMgr --> SharedConfig : Use PluginConfig paths
ProcessMgr --> EventSim : dotnet run/exec
ProcessMgr --> MetricLogger : dotnet run/exec

Router --> Listener : Listen()
Listener --> Stream : Accept TcpClient
Stream --> Router : Deliver NetworkStream
Router --> JsonCodec : Serialize/Deserialize Message
EventSim --> Stream : TcpClient + JSON
MetricLogger --> Stream : TcpClient + JSON

EventSim --> MessageSchema : Handshake + Heartbeat + CommandRequest
MetricLogger --> MessageSchema : Handshake + Heartbeat + CommandRequest
EventSim --> DomainEvents : Produce payloads
MetricLogger --> DomainEvents : Deserialize payloads

Router --> Registry : Update connection + LastReceived
Router --> HBLog : LogHeartbeat(pluginId, seq)
Router --> MessageSchema : Wrap + inspect metadata
Router --> MetricLogger : Broadcast CommandRequest
EventSim --> Router : Handshake/Heartbeat/User events

HBMonitor --> Registry : Inspect LastReceived
HBMonitor --> ProcessMgr : Restart missing plugin
CommandUI --> Registry : list status
CommandUI --> ProcessMgr : start/kill plugin

MetricLogger --> MetricsLog : Append counters
SharedConfig --> MetricLogger : Host/port overrides

note right of EventSim
- Sends handshake once on connect
- Emits heartbeats every 2s
- Alternates UserLoggedInEvent and DataProcessedEvent payloads
end note

note right of MetricLogger
- Subscribes to CommandRequest broadcast
- Counts events per type and writes metriclogger-metrics.log
- Supports exitAfterSeconds + kernel overrides
end note

note bottom of Router
Broadcast keeps Metadata.Sender so receivers know origin
Simple newline framing; TLS not implemented yet
end note

@enduml

